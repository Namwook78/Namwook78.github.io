# ORACLE SQL 6장

- - 6장
-- 2장 CREATE, ALTER, DROP
-- 3장 SELECT, UPDATE, DELETE, INSERT
-- 4장 다양한 함수, 연산자
-- 5장 그룹 쿼리 (Groupby)
- - p.198~199 안함

SELECT
period
, region
, SUM(loan_jan_amt) totl_jan
FROM kor_loan_status
WHERE period = '201311'
GROUP BY period, region
HAVING SUM(loan_jan_amt) > 100000
ORDER BY region;

- - 테이블 p.176
-- 동등 조인
SELECT
a.employee_id
, a.emp_name
, a.department_id
, b.department_name
FROM
employees a
, departments b
WHERE a.department_id = b.department_id;
- - 세미조인
-- 서브쿼리를 사용함
-- 서브 쿼리에 존재하는 데이터만 메인 쿼리에서 ㅊ출
-- IN & EXISTS
- - EXISTS 사용
SELECT
department_id
, department_name
FROM departments a
WHERE EXISTS (SELECT *
FROM employees b
WHERE a.department_id = b.department_id
AND b.salary > 3000
) -- EXISTS
ORDER BY a.department_name;
- - IN 사용
SELECT
department_id
, department_name
FROM departments a
WHERE a.department_id IN (SELECT
b.department_id
FROM employees b
WHERE b.salary > 3000)
ORDER BY a.department_name;
- - 안티 조인
-- 세미 조인 개념의 반대
-- 서브쿼리의 B 테이블에는 없는 메인 쿼리의 A 테이블의 데이터만 추출

SELECT
a.employee_id
, a.emp_name
, a.department_id
, b.department_name
FROM
employees a
, departments b
WHERE a.department_id = b.department_id
AND a.department_id NOT IN (SELECT department_id
FROM departments
WHERE manager_id IS NULL);

- - 셀프조인
-- 동일한 한 테이블에서 조인하는 방법
SELECT
a.employee_id
, a.emp_name
, b.employee_id
, b.emp_name
, a.department_id
FROM
employees a
, employees b
WHERE a.employee_id < b.employee_id
AND a.department_id = b.department_id
AND a.department_id = 20;
- - OUTER JOIN
-- 조인 조건에 만족하지 않더라도 데이터를 모두 추출함
-- 무조건 ID가 매칭이 된 것만 조회
SELECT
a.department_id
, a.department_name
, b.job_id
, b.department_id
FROM
departments a
, job_history b
WHERE a.department_id = b.department_id;

SELECT
a.department_id
, a.department_name
, b.job_id
, b.department_id
FROM
departments a
, job_history b
WHERE a.department_id = b.department_id(+);

- -
SELECT
a.employee_id
, a.emp_name
, b.job_id
, b.department_id
FROM
employees a
, job_history b
WHERE a.employee_id = b.employee_id(+)
AND a.department_id = b.department_id(+);
- - 카타시안 조인
-- 사원 테이블의 총 건수는 107건
-- 부서 테이블의 총 건수는 27건
-- 107 x 27 = 2,889건
- - ANSI 조인
-- ANSI SQL 문법 (JOIN 명 들어감)
- - 2013년 1월 1일 이후에 입사한
-- 사원번호, 사원명 부서번호, 부서명을 조회하는 쿼리 비교
-- 기존 문법
SELECT
a.employee_id
, a.emp_name
, a.hire_date
, b.department_id
, b.department_name
FROM
employees a
, departments b
WHERE a.department_id = b.department_id
AND a.hire_date >= TO_DATE('2003-01-01', 'YYYY-MM-DD');
- - ANSI
SELECT
a.employee_id
, a.emp_name
, a.hire_date
, b.department_id
, b.department_name
FROM
employees a
INNER JOIN departments b
ON (a.department_id = b.department_id)
WHERE a.hire_date >= TO_DATE('2003-01-01', 'YYYY-MM-DD');
- - 서브쿼리
-- SQL 문장 안에서 보조로 사용되는 또 다른 SELECT 문을 의미
-- 구조 : (1) 메인 쿼리 / (2) 서브 쿼리
- - 연관성 없는 서브 쿼리
SELECT * FROM employees; -- 107개의 행
- - 메인쿼리 : 모든 사원 테이블을 조회하세요
-- 서브쿼리 : 조건 - 사원테이블의 평균 급여보다 많은 사원
-- 결괏값은 51개

SELECT AVG(salary) FROM employees;

SELECT *
FROM employees
WHERE salary >= (SELECT AVG(salary) FROM employees);

- - parent_id가 NULL인 부서번호를 가진 총 사원의 건수
SELECT department_id
FROM departments
WHERE parent_id IS NULL;

SELECT count(*)
FROM employees
WHERE department_id IN (SELECT department_id
FROM departments
WHERE parent_id IS NULL);

SELECT employee_id, job_id FROM job_history;
SELECT
employee_id
, emp_name
, job_id
FROM employees
WHERE (employee_id, job_id) IN (SELECT
employee_id
, job_id
FROM job_history);

- - 연관성 있는 서브 쿼리
SELECT 1
FROM
departments a
, job_history b
WHERE a.department_id = b.department_id;

SELECT
a.department_id
, a.department_name
FROM departments a
WHERE EXISTS (SELECT 1
FROM job_history b
WHERE a.department_id = b.department_id);

- - SELECT 절에 서브쿼리가 존재하는 케이스
SELECT
a.employee_id
, (SELECT b.emp_name
FROM employees b
WHERE a.employee_id = b.employee_id) AS emp_name
, a.department_id
, (SELECT b.department_name
FROM departments b
WHERE a.department_id = b.department_id) AS dep_name
, (SELECT c.job_title
FROM jobs c
WHERE a.job_id = c.job_id) AS title_name
FROM job_history a;
- - 중첩 서브쿼리
SELECT
a.department_id
, a.department_name
FROM
departments a
WHERE EXISTS ( SELECT 1
FROM employees b
WHERE a.department_id = b.department_id
AND b.salary > (SELECT AVG(salary) FROM employees)
);
-- p.200
-- 복잡한 쿼리 작성법 예시
-- (1), (2) ---> 메인쿼리 작성
-- (3), (4) ---> 서브쿼리 작성 후 합치기
- - 연도별로 이탈리아 매출 데이터를 살펴
-- 매출실적이 가장 많은 사원의 목록과 매출액을 구하라
-- 연도, 최대매출사원, 최대매출액
-- 이탈리아 찾기 : countries
-- 이탈리아 고객 : customers
-- 매출 : sales
-- 사원정보 : employees
- - (1) 연도, 사원별 이탈리아 매출액 구하기
-- 이탈리아 고객 찾기 : customers, countries country_id로 조인
-- 이탈리아 매출 찾기 : 위 결과와 sales 테이블을 cust_id로 조인
-- 최대 매출액 구하려면 MAX 함수 쓰고, 연도별로 GROUP BY
SELECT
SUBSTR(a.sales_month, 1, 4) as years
, a.employee_id
, SUM(a.amount_sold) AS amount_sold
FROM
sales a
, customers b
, countries c
WHERE a.cust_id = b.cust_id
AND b.country_id = c.country_id
AND c.country_name = 'Italy'
GROUP BY SUBSTR(a.sales_month, 1, 4), a.employee_id;
- - (2) (1) 결과에서 연도별 최대, 최소 매출액 구하기
SELECT
years
, MAX(amount_sold) AS max_sold
, MIN(amount_sold) AS min_sold
FROM (SELECT
SUBSTR(a.sales_month, 1, 4) as years
, a.employee_id
, SUM(a.amount_sold) AS amount_sold
FROM
sales a
, customers b
, countries c
WHERE a.cust_id = b.cust_id
AND b.country_id = c.country_id
AND c.country_name = 'Italy'
GROUP BY SUBSTR(a.sales_month, 1, 4), a.employee_id) K
GROUP BY years
ORDER BY years;
- - (3) (1) 결과와 (2) 결과를 조인해서
-- 최대매출, 최소매출액을 일으킨 사원을 찾는다.

SELECT
emp.years
, emp.employee_id
, emp2.emp_name
, emp.amount_sold
FROM
(SELECT
SUBSTR(a.sales_month, 1, 4) as years
, a.employee_id
, SUM(a.amount_sold) AS amount_sold
FROM
sales a
, customers b
, countries c
WHERE a.cust_id = b.cust_id
AND b.country_id = c.country_id
AND c.country_name = 'Italy'
GROUP BY SUBSTR(a.sales_month, 1, 4), a.employee_id) emp
, (SELECT
years
, MAX(amount_sold) AS max_sold
, MIN(amount_sold) AS min_sold
FROM (SELECT
SUBSTR(a.sales_month, 1, 4) as years
, a.employee_id
, SUM(a.amount_sold) AS amount_sold
FROM
sales a
, customers b
, countries c
WHERE a.cust_id = b.cust_id
AND b.country_id = c.country_id
AND c.country_name = 'Italy'
GROUP BY SUBSTR(a.sales_month, 1, 4), a.employee_id) K
GROUP BY years) sale
, employees emp2
WHERE emp.years = sale.years
AND emp.amount_sold = sale.max_sold
AND emp.employee_id = emp2.employee_id
ORDER BY years;